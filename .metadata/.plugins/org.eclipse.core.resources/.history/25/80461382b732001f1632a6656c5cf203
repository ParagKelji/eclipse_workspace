package com.f8.test;

public class StreamsEx {

	import java.util.*;
	import java.util.stream.Collectors;
	class Product{
	    int id;
	    String name;
	    float price;
	    public Product(int id, String name, float price) {
	        this.id = id;
	        this.name = name;
	        this.price = price;
	    }
	}
	public class JavaStreamExample {
	    public static void main(String[] args) {
	        List<Product> productsList = new ArrayList<Product>();
	        //Adding Products
	        productsList.add(new Product(1,"HP Laptop",25000f));
	        productsList.add(new Product(2,"Dell Laptop",30000f));
	        productsList.add(new Product(3,"Lenevo Laptop",28000f));
	        productsList.add(new Product(4,"Sony Laptop",28000f));
	        productsList.add(new Product(5,"Apple Laptop",90000f));
	        List<Float> productPriceList2 =productsList.stream()
	                                     .filter(p -> p.price > 30000)// filtering data
	                                     .map(p->p.price)        // fetching price
	                                     .collect(Collectors.toList()); // collecting as list
	        System.out.println(productPriceList2);
	    }
	}
	Output:

	[90000.0]
	Java Stream Iterating Example
	You can use stream to iterate any number of times. Stream provides predefined methods to deal with the logic you implement. In the following example, we are iterating, filtering and passed a limit to fix the iteration.

	import java.util.stream.*;
	public class JavaStreamExample {
	    public static void main(String[] args){
	        Stream.iterate(1, element->element+1)
	        .filter(element->element%5==0)
	        .limit(5)
	        .forEach(System.out::println);
	    }
	}
	Output:

	5
	10
	15
	20
	25
	Java Stream Example: Filtering and Iterating Collection
	In the following example, we are using filter() method. Here, you can see code is optimized and very concise.
	ADVERTISEMENT

	ADVERTISEMENT

	import java.util.*;
	class Product{
	    int id;
	    String name;
	    float price;
	    public Product(int id, String name, float price) {
	        this.id = id;
	        this.name = name;
	        this.price = price;
	    }
	}
	public class JavaStreamExample {
	    public static void main(String[] args) {
	        List<Product> productsList = new ArrayList<Product>();
	        //Adding Products
	        productsList.add(new Product(1,"HP Laptop",25000f));
	        productsList.add(new Product(2,"Dell Laptop",30000f));
	        productsList.add(new Product(3,"Lenevo Laptop",28000f));
	        productsList.add(new Product(4,"Sony Laptop",28000f));
	        productsList.add(new Product(5,"Apple Laptop",90000f));
	        // This is more compact approach for filtering data
	        productsList.stream()
	                             .filter(product -> product.price == 30000)
	                             .forEach(product -> System.out.println(product.name));
	    }
	}
	Output:

	Dell Laptop
	Java Stream Example : reduce() Method in Collection
	This method takes a sequence of input elements and combines them into a single summary result by repeated operation. For example, finding the sum of numbers, or accumulating elements into a list.

	In the following example, we are using reduce() method, which is used to sum of all the product prices.

	import java.util.*;
	class Product{
	    int id;
	    String name;
	    float price;
	    public Product(int id, String name, float price) {
	        this.id = id;
	        this.name = name;
	        this.price = price;
	    }
	}
	public class JavaStreamExample {
	    public static void main(String[] args) {
	        List<Product> productsList = new ArrayList<Product>();
	        //Adding Products
	        productsList.add(new Product(1,"HP Laptop",25000f));
	        productsList.add(new Product(2,"Dell Laptop",30000f));
	        productsList.add(new Product(3,"Lenevo Laptop",28000f));
	        productsList.add(new Product(4,"Sony Laptop",28000f));
	        productsList.add(new Product(5,"Apple Laptop",90000f));
	        // This is more compact approach for filtering data
	        Float totalPrice = productsList.stream()
	                    .map(product->product.price)
	                    .reduce(0.0f,(sum, price)->sum+price);   // accumulating price
	        System.out.println(totalPrice);
	        // More precise code
	        float totalPrice2 = productsList.stream()
	                .map(product->product.price)
	                .reduce(0.0f,Float::sum);   // accumulating price, by referring method of Float class
	        System.out.println(totalPrice2);

	    }
	}
	Output:

	201000.0
	201000.0
	Java Stream Example: Sum by using Collectors Methods
	We can also use collectors to compute sum of numeric values. In the following example, we are using Collectors class and it?s specified methods to compute sum of all the product prices.

	import java.util.*;
	import java.util.stream.Collectors;
	class Product{
	    int id;
	    String name;
	    float price;
	    public Product(int id, String name, float price) {
	        this.id = id;
	        this.name = name;
	        this.price = price;
	    }
	}
	public class JavaStreamExample {
	    public static void main(String[] args) {
	        List<Product> productsList = new ArrayList<Product>();
	        //Adding Products
	        productsList.add(new Product(1,"HP Laptop",25000f));
	        productsList.add(new Product(2,"Dell Laptop",30000f));
	        productsList.add(new Product(3,"Lenevo Laptop",28000f));
	        productsList.add(new Product(4,"Sony Laptop",28000f));
	        productsList.add(new Product(5,"Apple Laptop",90000f));
	        // Using Collectors's method to sum the prices.
	        double totalPrice3 = productsList.stream()
	                        .collect(Collectors.summingDouble(product->product.price));
	        System.out.println(totalPrice3);

	    }
	}
	Output:

	201000.0
	Java Stream Example: Find Max and Min Product Price
	Following example finds min and max product price by using stream. It provides convenient way to find values without using imperative approach.

	import java.util.*;
	class Product{
	    int id;
	    String name;
	    float price;
	    public Product(int id, String name, float price) {
	        this.id = id;
	        this.name = name;
	        this.price = price;
	    }
	}
	public class JavaStreamExample {
	    public static void main(String[] args) {
	        List<Product> productsList = new ArrayList<Product>();
	        //Adding Products
	        productsList.add(new Product(1,"HP Laptop",25000f));
	        productsList.add(new Product(2,"Dell Laptop",30000f));
	        productsList.add(new Product(3,"Lenevo Laptop",28000f));
	        productsList.add(new Product(4,"Sony Laptop",28000f));
	        productsList.add(new Product(5,"Apple Laptop",90000f));
	        // max() method to get max Product price
	        Product productA = productsList.stream().max((product1, product2)->product1.price > product2.price ? 1: -1).get();
	        System.out.println(productA.price);
	        // min() method to get min Product price
	        Product productB = productsList.stream().min((product1, product2)->product1.price > product2.price ? 1: -1).get();
	        System.out.println(productB.price);

	    }
	}
	Output:

	90000.0
	25000.0
	Java Stream Example: count() Method in Collection
	import java.util.*;
	class Product{
	    int id;
	    String name;
	    float price;
	    public Product(int id, String name, float price) {
	        this.id = id;
	        this.name = name;
	        this.price = price;
	    }
	}
	public class JavaStreamExample {
	    public static void main(String[] args) {
	        List<Product> productsList = new ArrayList<Product>();
	        //Adding Products
	        productsList.add(new Product(1,"HP Laptop",25000f));
	        productsList.add(new Product(2,"Dell Laptop",30000f));
	        productsList.add(new Product(3,"Lenevo Laptop",28000f));
	        productsList.add(new Product(4,"Sony Laptop",28000f));
	        productsList.add(new Product(5,"Apple Laptop",90000f));
	        // count number of products based on the filter
	        long count = productsList.stream()
	                    .filter(product->product.price<30000)
	                    .count();
	        System.out.println(count);
	    }
	}
	Output:

	3
	stream allows you to collect your result in any various forms. You can get you result as set, list or map and can perform manipulation on the elements.

	Java Stream Example : Convert List into Set
	import java.util.*;
	import java.util.stream.Collectors;
	class Product{
	    int id;
	    String name;
	    float price;
	    public Product(int id, String name, float price) {
	        this.id = id;
	        this.name = name;
	        this.price = price;
	    }
	}

	public class JavaStreamExample {
	    public static void main(String[] args) {
	        List<Product> productsList = new ArrayList<Product>();

	        //Adding Products
	        productsList.add(new Product(1,"HP Laptop",25000f));
	        productsList.add(new Product(2,"Dell Laptop",30000f));
	        productsList.add(new Product(3,"Lenevo Laptop",28000f));
	        productsList.add(new Product(4,"Sony Laptop",28000f));
	        productsList.add(new Product(5,"Apple Laptop",90000f));

	        // Converting product List into Set
	        Set<Float> productPriceList =
	            productsList.stream()
	            .filter(product->product.price < 30000)   // filter product on the base of price
	            .map(product->product.price)
	            .collect(Collectors.toSet());   // collect it as Set(remove duplicate elements)
	        System.out.println(productPriceList);
	    }
	}
	Output:

	[25000.0, 28000.0]
	Java Stream Example : Convert List into Map
	import java.util.*;
	import java.util.stream.Collectors;
	class Product{
	    int id;
	    String name;
	    float price;
	    public Product(int id, String name, float price) {
	        this.id = id;
	        this.name = name;
	        this.price = price;
	    }
	}

	public class JavaStreamExample {
	    public static void main(String[] args) {
	        List<Product> productsList = new ArrayList<Product>();

	        //Adding Products
	        productsList.add(new Product(1,"HP Laptop",25000f));
	        productsList.add(new Product(2,"Dell Laptop",30000f));
	        productsList.add(new Product(3,"Lenevo Laptop",28000f));
	        productsList.add(new Product(4,"Sony Laptop",28000f));
	        productsList.add(new Product(5,"Apple Laptop",90000f));

	        // Converting Product List into a Map
	        Map<Integer,String> productPriceMap =
	            productsList.stream()
	                        .collect(Collectors.toMap(p->p.id, p->p.name));

	        System.out.println(productPriceMap);
	    }
	}
	Output:

	{1=HP Laptop, 2=Dell Laptop, 3=Lenevo Laptop, 4=Sony Laptop, 5=Apple Laptop}
	Method Reference in stream
	import java.util.*;
	import java.util.stream.Collectors;

	class Product{
	    int id;
	    String name;
	    float price;

	    public Product(int id, String name, float price) {
	        this.id = id;
	        this.name = name;
	        this.price = price;
	    }

	    public int getId() {
	        return id;
	    }
	    public String getName() {
	        return name;
	    }
	    public float getPrice() {
	        return price;
	    }
	}

	
    public static void main(String[] args) {

        List<Product> productsList = new ArrayList<Product>();

        //Adding Products
        productsList.add(new Product(1,"HP Laptop",25000f));
        productsList.add(new Product(2,"Dell Laptop",30000f));
        productsList.add(new Product(3,"Lenevo Laptop",28000f));
        productsList.add(new Product(4,"Sony Laptop",28000f));
        productsList.add(new Product(5,"Apple Laptop",90000f));

        List<Float> productPriceList =
                productsList.stream()
                            .filter(p -> p.price > 30000) // filtering data
                            .map(Product::getPrice)         // fetching price by referring getPrice method
                            .collect(Collectors.toList());  // collecting as list
        System.out.println(productPriceList);
	}

}
